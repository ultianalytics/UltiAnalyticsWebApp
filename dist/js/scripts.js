'use strict';
// gotta get that footer positioned properly. This seemed like a good spot for some errant code.
$('.main-view').css('min-height', window.innerHeight - $('.extra').outerHeight() - $('.footer').outerHeight())
$(window).resize(function(){
  $('.main-view').css('min-height', window.innerHeight - $('.extra').outerHeight() - $('.footer').outerHeight())
})

angular.module('newBetaApp', [
  'ngRoute',
  'ngAnimate',
  'ngCookies'
])
  .config(['$routeProvider',
    function($routeProvider) {
      function checkAuth($location, Authorization, next) {
        next.set($location.path());
        return Authorization.ping($location.url().match(/^\/\d+/)[0].slice(1));
      }
      // function checkPlayerExistence ($q, $location, api) {
      //   api.retrieveTeam($location.url().match(/^\/\d+/)[0].slice(1), true, function(response){
      //     if (_(response.players).pluck('name').contains(decodeURI($location.url().match(/\/[^\/]+$/)[0].slice(1)))){
      //       deferred.resolve();
      //     } else {
      //       $location.url('/404');
      //       deferred.resolve(new Error('bad player name'));
      //     }
      //   });
      //   var deferred = $q.defer();
      //   return deferred.promise;
      // }


      $routeProvider
        .when('/', {templateUrl: 'views/splash.html', controller: 'SplashCtrl'}) .when('/:teamId/login', {templateUrl: 'views/login.html', controller: 'LoginCtrl'})
        .when('/:teamId/players', {templateUrl: 'views/players.html', controller: 'PlayersCtrl', resolve: {authorized: checkAuth}})
        .when('/:teamId/team', {templateUrl: 'views/team.html', controller: 'TeamCtrl', resolve: {authorized: checkAuth}})
        .when('/:teamId/download', {templateUrl: 'views/download.html', controller: 'DownloadCtrl', resolve: {authorized: checkAuth}})
        .when('/:teamId/line', {templateUrl: 'views/line.html', controller: 'LineCtrl', resolve: {authorized: checkAuth}})
        .when('/:teamId/games', {templateUrl: 'views/games.html', controller: 'GamesCtrl', resolve: {authorized: checkAuth}})
        .when('/:teamId/player/:playerNameUri', {templateUrl: 'views/player.html', controller: 'PlayerCtrl', resolve: { authorized: checkAuth}})
        .when('/404', {templateUrl: 'views/404.html', controller: '404Ctrl'})
        .otherwise({redirectTo: '/404'});
    }
  ]);;'use strict';

angular.module('newBetaApp')
  .controller('404Ctrl', ['$scope',function ($scope) {
  }]);
;// Generated by CoffeeScript 1.7.1
angular.module('newBetaApp').controller('DownloadCtrl', [
  '$scope', 'downloadUrl', function($scope, downloadUrl) {
    return $scope.url = downloadUrl;
  }
]);
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .controller('FilterCtrl', ['$scope', 'filter', 'allGames', function($scope, filter, allGames) {
    $scope.dDOpen = false;
    $scope.filter = filter;
    $scope.buttonMessage = 'All Games';
    allGames.then(function(games) {
      $scope.allGames = games;
      $scope.numberOfGames = Object.keys(games).length;
      $scope.mostRecentGame = _.max(games, function(item) {
        return item.msSinceEpoch;
      });
      $scope.tournaments = _.groupBy(games, 'tournamentName');
      $scope.mostRecentTournamentName = $scope.mostRecentGame.tournamentName;
      $scope.mostRecentTournament = $scope.mostRecentTournamentName ? $scope.tournaments[$scope.mostRecentGame.tournamentName] : null;
      if ($scope.tournaments && $scope.tournaments['undefined']) {
        $scope.tournaments['-'] = $scope.tournaments['undefined'];
        delete $scope.tournaments['undefined'];
      }
    });

    function orderLayout() {
      $scope.orderedTournaments = _.map($scope.tournaments,function(games) {
        return _.toArray(games).sort(function(a, b) {
          return b.msSinceEpoch - a.msSinceEpoch;
        });
      }).sort(function(a, b) {
        return b[0].msSinceEpoch - a[0].msSinceEpoch;
      });
    }
    $scope.collect = function() {
      orderLayout();
      $scope.dDOpen = true;
    };
    $scope.close = function() {$scope.dDOpen = false;};
    $scope.isIncluded = filter.contains;
    $scope.allIncluded = function(games){
      return _.reduce(games, function(memo, game){
        return memo && $scope.isIncluded(game);
      }, true);
    };
    $scope.toggleAll = function(games, choice){
      _.each(games, function(game){
        $scope.toggleSelect(game, choice);
      });
    };
    $scope.toggleSelect = function(game, choice){
      (!filter.contains(game) || choice) ? filter.include(game) : filter.exclude(game);
    };
    var $dedicatedScope = $scope.$new();
    $dedicatedScope.included = filter.included;
    $dedicatedScope.$watchCollection('included', function(currentGames){

      // this is the logic for the filter button's message. It's a nest, I know, but it's O(n).
      // if tournaments have been established, run the following logic:
        // Say all games (n games) if all are selected.
        // else Say a tournament name (+n games other than that tournament)
        // else Say the most recent game selected, and (+n games other than selected)
      // if there are any games selected and no tournaments, it means this is the first load, ergo append the number of games to the message so it's All Games (n games), instead of just all games.
      // Otherwise they don't have any stats recorded, so tell them. 
      //TODO: unit test this piece of shit...


      if ($scope.tournaments){
        var possibilities = {
          total: true,
          tournaments: _.clone($scope.tournaments),
          games: _.clone($scope.allGames, 'gameId')
        };
        delete possibilities.tournaments['-'];
        var current = _(currentGames).indexBy('gameId').valueOf();
        _.each($scope.allGames, function(game){
          if (!_(current).has(game.gameId)){
            delete possibilities.total;
            delete possibilities.tournaments[game.tournamentName];
            delete possibilities.games[game.gameId];
          }
        });
        if (possibilities.total){
          $scope.buttonMessage = 'All Games ' + '(' + currentGames.length + ' games)';
        } else if (_.keys(possibilities.tournaments).length){
          var tourney = _(possibilities.tournaments).sample();
          var extraGames = currentGames.length - tourney.length ? ' (+' + (currentGames.length - tourney.length) + ' games)' : '';
          $scope.buttonMessage = tourney[0].tournamentName + extraGames;
        } else if (currentGames.length){
          var extraGames = currentGames.length > 1 ? ' (+' + (currentGames.length - 1) + ' games)' : '';
          $scope.buttonMessage = _.min(currentGames, 'msSinceEpoch').opponentName + extraGames;
        } else {
          $scope.buttonMessage = 'Zero Games Selected!';
        }
      } else if (currentGames.length) {
        $scope.buttonMessage += ' (' + currentGames.length + ' games)';
      } else {
        $scope.buttonMessage = 'You don\'t have any stats!';
      }
    });
  }]);;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').controller('GamesCtrl', [
  '$scope', '$q', '$location', 'allGames', 'playerStats', 'gameStats', 'filter', 'relocate', function($scope, $q, $location, allGames, playerStats, gameStats, filter, relocate) {
    var openPoints, scope;
    scope = $scope;
    scope.relocate = relocate;
    scope.loading = true;
    $q.all([allGames, playerStats, gameStats, filter]).then(function(responses) {
      var id;
      allGames = responses[0];
      gameStats = responses[2];
      filter = responses[3];
      try {
        id = _.keys($location.search())[0];
        if (allGames[id]) {
          scope.select(allGames[id]);
        } else {
          scope.select(_.max(allGames, function(game) {
            return game.msSinceEpoch;
          }));
        }
      } catch (_error) {
        scope.select(_.max(allGames, function(game) {
          return game.msSinceEpoch;
        }));
      }
      scope.loading = false;
      return scope.sortedGames = _.toArray(allGames);
    });
    scope.isSelectedGame = function(game) {
      return game === scope.selectedGame;
    };
    scope.select = function(game) {
      scope.gameLoading = true;
      filter.onlyInclude([game]);
      $location.search(game.gameId);
      scope.selectedGame = game;
      scope.gameStats = gameStats.getFor(game);
      return scope.gameLoading = false;
    };
    openPoints = {};
    scope.togglePoints = function(points, only) {
      if (only) {
        openPoints = {};
      }
      return _(points).pluck('$$hashKey').each(function(id) {
        return openPoints[id] = !openPoints[id];
      });
    };
    return scope.isOpen = function(point) {
      return openPoints[point['$$hashKey']];
    };
  }
]);
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').controller('LineCtrl', [
  '$scope', 'lineStats', 'Line', 'filter', function($scope, lineStats, Line, filter) {
    var scope;
    scope = $scope;
    scope.dragging;
    scope.selectedLine;
    scope.lines = {};
    scope.includedGames = filter.included;
    $scope.loading = true;
    lineStats.then(function(response) {
      lineStats = response;
      $scope.players = lineStats.getPlayers();
      return $scope.loading = false;
    });
    scope.setDragging = function(player) {
      return scope.dragging = player;
    };
    scope.addLine = function() {
      var line;
      line = new Line;
      scope.lines[line.id] = line;
      return scope.selectedLine = line;
    };
    scope.removeLine = function(line) {
      return delete scope.lines[line.id];
    };
    scope.addPlayerToSelected = function(player) {
      return scope.selectedLine.addPlayer(player);
    };
    scope.selectLine = function(line) {
      return scope.selectedLine = line;
    };
    scope._contains = _.contains;
    scope.addLine();
    return scope.$watchCollection('includedGames', function(update, old) {
      if (update && lineStats.getStats) {
        return _(scope.lines).each(function(line) {
          return line.updateStats();
        });
      }
    });
  }
]);
;'use strict';

angular.module('newBetaApp')
  .controller('LoginCtrl', ['$scope', '$routeParams', '$location', 'api', 'next', function($scope, $routeParams, $location, api, next) {
    $scope.attempt = function(password) {
      if (password){
        console.log(password);
        $scope.inAttempt = true;
        api.signon($routeParams.teamId, password,
          function() {
            var goTo = next.get();
            goTo ? $location.path(goTo) : $location.path($routeParams.teamId + '/players');
            $scope.$apply();
          }, function() {
            $scope.inAttempt = false;
            $scope.failedAttempt = true;
            $scope.$digest();
          });
      }
    };
  }]);;'use strict';

angular.module('newBetaApp')
  .controller('MainCtrl', ['$scope', function ($scope) {
    $scope.awesomeThings = [
      'HTML5 Boilerplate',
      'AngularJS',
      'Karma'
    ];
  }]);
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').controller('PlayerCtrl', [
  '$scope', '$routeParams', '$q', 'allGames', 'playerExtensionStats', 'filter', function($scope, $routeParams, $q, allGames, playerExtensionStats, filter) {
    var init, players, scope;
    scope = $scope;
    scope.loading = true;
    scope.console = console;
    players = null;
    scope.playerName = decodeURI($routeParams.playerNameUri);
    $q.all([allGames, playerExtensionStats]).then(function(responses) {
      allGames = responses[0];
      playerExtensionStats = responses[1];
      init();
      return scope.loading = false;
    });
    return init = function() {
      filter.includeAll();
      scope.included = filter.included;
      playerExtensionStats.setPlayer(scope.playerName);
      return scope.$watchCollection('included', function() {
        playerExtensionStats.setGames(scope.included);
        return scope.targetStats = playerExtensionStats.getTargetMap();
      });
    };
  }
]);
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .controller('PlayersCtrl', ['$scope', '$q', 'playerStats', 'allGames', 'filter', 'relocate', function ($scope, $q, playerStats, allGames, filter, relocate) {
    $scope.relocate = relocate;
    $scope.loading = true;
    $scope.sortBy = 'name';
    $q.all([playerStats, allGames]).then(function(responses){
      filter.includeAll();
      playerStats = responses[0];
      allGames = responses[1];
      playerStats.setGames(allGames);
      $scope.playerStats = playerStats.getAll();
      $scope.statTypes = playerStats.statTypes;
      $scope.numberOfGames = Object.keys(allGames).length;
      $scope.included = filter.included;
      $scope.$watchCollection('included', function(){
        playerStats.setGames(filter.included);
        $scope.playerStats = playerStats.getAll();
        render(); // fucking digest loop.
      });
      $scope.loading = false;
      render();
    });
    $scope.console = console;
    $scope.leaderMap = {
      goals: {
        category: 'Offense',
        stats: ['goals', 'assists','touches']
      },
      ds : {
        category: 'Defense',
        stats: ['ds','dPoints', 'pulls']
      },
      plusMinus: {
        category: 'Plus / Minus',
        stats: ['plusMinus', 'oPlusMinus','dPlusMinus']
      },
      pointsPlayed: {
        category: 'Playing Time',
        stats: ['oPoints','dPoints','timePlayedMinutes']
      }
    };
    function render() {
      $scope.leaders = playerStats.getLeaders(['goals','ds','pointsPlayed', 'plusMinus']);
    }
  }]);
;'use strict';

angular.module('newBetaApp')
  .controller('SplashCtrl', ['$scope', function ($scope) {
    $scope.awesomeThings = [
      'HTML5 Boilerplate',
      'AngularJS',
      'Karma'
    ];
  }]);
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .controller('StattablesCtrl', ['$scope', '$location','$routeParams', 'playerStats', 'filter', 'relocate', function($scope, $location,$routeParams, playerStats, filter, relocate) {
    $scope.relocate = relocate;
    $scope.changeFocus = function(type) {
      $scope.focus = type;
    };
    playerStats.then(function(statsApi) {
      playerStats = statsApi;
      init();
    });
    $scope.categories = [{
      name: 'Passing',
      statTypes: ['assists', 'completions', 'throwaways','stalls', 'passingPercentage']
    }, {
      name: 'Receiving',
      statTypes: ['goals','catches','touches','drops','catchingPercentage']
    }, {
      name: 'Playing Time',
      statTypes: ['gamesPlayed','pointsPlayed','timePlayedMinutes', 'oPoints', 'dPoints']
    }, {
      name: 'Defense',
      statTypes: ['ds','pulls','callahans','averagePullHangtime','oBPulls',]
    }, {
      name: 'Per Point',
      statTypes: ['ppGoals' ,'ppAssists', 'ppDs' , 'ppThrowaways' , 'ppDrops']
    }, ];
    $scope.focus = $scope.categories[0];
    $scope.games = filter.included; // updated by the filter controller.
    $scope.sorter = '-name';
    function init(){
      $scope.stats = playerStats.getAll();
      $scope.players = _.keys($scope.stats);
      $scope.statTypes = _.keys($scope.stats[$scope.players[0]].stats);
      startWatching();
    }
    function startWatching(){
      $scope.$watchCollection('games', function(nv, ov) {
        playerStats.setGames(filter.included);
        $scope.stats = playerStats.getAll();
        $scope.statsArray = _.toArray($scope.stats);
        $scope.players = _.keys($scope.stats);
        $scope.statTypes = _.keys($scope.stats[$scope.players[0]].stats);
        $scope.totals = playerStats.getTotals();
        $scope.averages = playerStats.getAverages();
      });
    }
    $scope.sort = function(obj, prop){
      var name;
      prop ? name = obj + '.' + prop : name = obj;
      ($scope.sorter === name) ? $scope.sorter = '-' + $scope.sorter : $scope.sorter = name;
    };
  }]);
  ;'use strict';

angular.module('newBetaApp')
  .controller('TeamCtrl', ['$scope', 'teamStats', '$location','filter',function($scope, teamStats, $location, filter) {
    $scope.loading = true;
    teamStats.then(function(api) {
      filter.includeAll()
      $scope.teamStats = api.getFromIncluded();
      $scope.loading = false;
    });
  }]);;'use strict';

angular.module('newBetaApp')
  .directive('checkbox', ['$parse',function ($parse) {
    return {
      restrict: 'A',
      link: function postLink(scope, element, attrs) {
        scope.$watch(attrs.watch, function(newVal){
          newVal ? element[0].checked = true: element[0].checked = false;
        });
      }
    };
  }]);
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').directive('draggable', [
  '$parse', function($parse) {
    return {
      restrict: 'A',
      link: function(scope, element, attrs) {
        var item, onDrag;
        item = $parse(attrs.item)(scope);
        onDrag = $parse(attrs.onDrag)(scope);
        return element.on('dragstart', function() {
          return onDrag(item);
        });
      }
    };
  }
]);
;
'use strict';

angular.module('newBetaApp')
  .directive('dropdownButton', ['$document',function ($document) {
    return {
      restrict: 'A',
      link: function postLink(scope, iElement) {
        var theElement;
        var display;
        var isOpen = false;
        var targeted = false;
        scope.dDRegister = function(element){
          theElement = element;
          hideElement();
          delete scope.dDRegister;
          theElement.on('click', function(e){
            targeted = true;
          });
        };
        iElement.on('click', function(){
          isOpen = !isOpen;
          if (isOpen){
            theElement.css('display', display);
          } else {
            hideElement();
          }
        });
        $document.on('click', function(e){
          if (e.target !== iElement[0] && !_.contains(iElement.children(), e.target)) {
            isOpen = false;
            theElement.css('display', 'none');
          }
        });
        function hideElement(){
          isOpen = false;
          display = theElement.css('display');
          theElement.css('display', 'none');
        }
      }
    };
  }]);
;'use strict';

angular.module('newBetaApp')
  .directive('dropdownTarget', function () {
    return {
      restrict: 'A',
      link: function postLink(scope, element) {
        scope.dDRegister(element);
      }
    };
  });
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').directive('droppable', [
  '$parse', function($parse) {
    return {
      restrict: 'A',
      scope: true,
      link: function(scope, element, attrs) {
        var onDrop, onEnter, onLeave;
        onEnter = $parse(attrs.onEnter)(scope);
        onLeave = $parse(attrs.onLeave)(scope);
        onDrop = $parse(attrs.onDrop)(scope);
        element.on('dragenter', function(event) {
          return typeof onEnter === "function" ? onEnter(scope.dragging) : void 0;
        });
        element.on('dragleave', function(event) {
          return typeof onLeave === "function" ? onLeave(scope.dragging) : void 0;
        });
        element.on('drop', function(event) {
          if (typeof onDrop === "function") {
            onDrop(scope.dragging);
          }
          return scope.$digest();
        });
        return element.on('dragover', function(event) {
          if (typeof onOver === "function") {
            onOver(scope.dragging);
          }
          return event.preventDefault();
        });
      }
    };
  }
]);
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').directive('feedback', [
  '$cookies', function($cookies) {
    return {
      templateUrl: 'includes/partials/feedback.html',
      restrict: 'E',
      link: function(scope, element, attrs) {
        console.log($cookies.iUltimateVisited);
        scope.gotMobileWarning = $cookies.iUltimateVisited === 'mobile';
        scope.firstTime = !$cookies.iUltimateVisited;
        scope.submitted = false;
        scope.closeFirstTimeModal = function() {
          scope.firstTime = true;
          $cookies.iUltimateVisited = 'true';
          try {
            $('.modal-backdrop').remove();
            return $('.modal').remove();
          } catch (_error) {}
        };
        return scope.closeMobileWarning = function() {
          scope.gotMobileWarning = true;
          $cookies.iUltimateVisited = 'mobile';
          console.log($cookies);
          try {
            $('.modal-backdrop').remove();
            return $('.modal').remove();
          } catch (_error) {}
        };
      }
    };
  }
]);
;/*global d3, angular */
angular.module('newBetaApp')
  .directive('flowChart', function() {
    return {
      restrict: 'AE',
      template: '<svg></svg>',
      scope: {
        dataset: '='
      },
      compile: function() {
        return {
          pre: function(scope, element) {
            scope.svg = d3.select(element.children()[0]);
          },
          post: function (scope, element) {
            scope.$watch('dataset', function(newVal, oldVal) {
              if (scope.dataset){
                if (newVal && oldVal){
                  element.contents().empty();
                }
                var margin = {
                  top: 1,
                  right: 1,
                  bottom: 6,
                  left: 1
                };
                var width = element[0].offsetWidth * .95;
                var height = width;

                var formatNumber = d3.format(',.0f');
                var format = function(d) {
                  return formatNumber(d) + ' Times';
                };
                var color = d3.scale.category20();

                scope.svg
                  .attr('width', width + margin.left + margin.right)
                  .attr('height', height + margin.top + margin.bottom)
                  .append('g')
                  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

                var sankey = d3.sankey()
                  .nodeWidth(15)
                  .nodePadding(10)
                  .size([width, height]);

                var path = sankey.link();

                sankey
                  .nodes(scope.dataset.nodes)
                  .links(scope.dataset.links)
                  .layout(32);

                var link = scope.svg.append('g').selectAll('.link')
                  .data(scope.dataset.links)
                  .enter().append('path')
                  .attr('class', 'link')
                  .attr('d', path)
                  .style('stroke-width', function(d) {
                    return Math.max(1, d.dy);
                  })
                  .sort(function(a, b) {
                    return b.dy - a.dy;
                  });

                link.append('title')
                  .text(function(d) {
                    return d.source.name.slice(0, d.source.name.length - 1) + ' â†’ ' + d.target.name.slice(0, d.target.name.length - 1) + '\n' + format(d.value);
                  });
                var node = scope.svg.append('g').selectAll('.node')
                  .data(scope.dataset.nodes)
                  .enter().append('g')
                  .attr('class', 'node')
                  .attr('transform', function(d) {
                    return 'translate(' + d.x + ',' + d.y + ')';
                  })
                  .call(d3.behavior.drag()
                    .origin(function(d) {
                      return d;
                    })
                    .on('dragstart', function() {
                      this.parentNode.appendChild(this);
                    })
                    .on('drag', dragmove));

                node.append('rect')
                  .attr('height', function(d) {
                    return d.dy;
                  })
                  .attr('width', sankey.nodeWidth())
                  .style('fill', function(d) {
                    return d.color = color(d.name.replace(/ .*/, ""));
                  })
                  .style('stroke', function(d) {
                    return d3.rgb(d.color).darker(2);
                  })
                  .append('title')
                  .text(function(d) {
                    return d.name + '\n' + format(d.value);
                  });

                node.append('text')
                  .attr('x', -6)
                  .attr('y', function(d) {
                    return d.dy / 2;
                  })
                  .attr('dy', '.35em')
                  .attr('text-anchor', 'end')
                  .attr('transform', null)
                  .text(function(d) {
                    return d.name.substring(0, d.name.length - 1);
                  })
                  .filter(function(d) {
                    return d.x < width / 2;
                  })
                  .attr('x', 6 + sankey.nodeWidth())
                  .attr('text-anchor', 'start');

                var dragmove = function(d) {
                  d3.select(this).attr('transform', 'translate(' + d.x + ',' + (d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))) + ')');
                  sankey.relayout();
                  link.attr('d', path);
                }
              }
            });
          }
        };
      }
    };
  });;/* global _ */

'use strict';

angular.module('newBetaApp')
  .directive('loading', function () {
    return {
      restrict: 'A',
      scope: {
        loading: '=',
        loadingType: '='
      },
      link: function preLink(scope, element){
        var message = '';
        if (!scope.loadingType || scope.loadingType.indexOf('icon') === -1){
          var i = -1;
          var myInt = setInterval(function(){
            if (++i === 4) {
              clearInterval(myInt);
            }
            element.children()[0].children[0].innerHTML = messages[i];
          },3000);
          var messages = [
            'Calculating Team Statistics...',
            'Determining content network...',
            'Uploading personal information...',
            'Lying about what this loading gif represents...'
          ];
          message = messages[0];
        }
        element.prepend('<span class="9827345987"><b id="87654">'+message+'</b><br><img width="30" src="images/ajax-loader.gif"></span>');
                scope.$watch('loading', function(newVal){
          _.each(element.children(), function(node){
            node.hidden = (node.classList.contains('9827345987') && !newVal) || (!node.classList.contains('9827345987') && newVal);
          });
        });
      }
    };
  });
;'use strict';

angular.module('newBetaApp')
  .directive('navBar', ['viewer', '$routeParams', '$location', '$rootScope', function (viewer, $routeParams, $location, $rootScope) {
    return {
      templateUrl: 'includes/partials/nav-bar.html',
      restrict: 'EA',
      scope: {
        page: '=',
      },
      link: function postLink(scope) {
        scope.playerName = decodeURI($routeParams.playerNameUri);
        $rootScope.isMobile = viewer.isMobile();
        scope.isMobile = viewer.isMobile();
        scope.isActive = function(option){
          return option === scope.page ? 'active' : '';
        };
        scope.navTo = function(page){
          var path = '/' + $routeParams.teamId + '/' + page;
          if (page !== scope.page){ $location.path(path); }
        };
        scope.toggleNav = function(){
          scope.navOpen = !scope.navOpen;
        };
      }
    };
  }]);
;'use strict';

angular.module('newBetaApp')
  .directive('onEnter', ['$parse', '$document', function ($parse, $document) {
    return {
      restrict: 'A',
      link: function postLink(scope, element, attrs) {
        var toDo = $parse(attrs.onEnter);
        $document.on('keyup', function(e){
          if (e.keyCode === 13){
            toDo(scope);
          }
        });
      }
    };
  }]);
;/* global d3, _ */

'use strict';

angular.module('newBetaApp')
  .directive('pieChart', ['$parse',function ($parse) {
    return {
      template: '<svg></svg>',
      restrict: 'AE',
      scope: {
        dataset: '='
      },
      compile: function () {
        return {
            pre: function(scope, element, attrs){
              scope.svg = d3.select(element.children()[0]);
            },
            post: function(scope, element, attrs){
              scope.$watch('dataset', function(newVal){
                if (newVal && _.keys(newVal).length) initialized ? change(newVal) : init(newVal);
              });
              var g;
              var initialized = false;
              var width = $parse(attrs.width)(scope);
              var height = $parse(attrs.height)(scope);
              var radius = Math.min(width, height) / 2;

              var enterClockwise = {startAngle: 0, endAngle: 0};
              var enterAntiClockwise = {startAngle: Math.PI * 2, endAngle: Math.PI * 2 };

              var color = d3.scale.category20();
              var pie = d3.layout.pie()
                .sort(null)
                .value(function(d){ return d.iterations });

              var arc = d3.svg.arc().innerRadius(0).outerRadius(radius - 10);

              scope.svg
                  .attr('width', width)
                  .attr('height', height)
                .append('g')
                  .attr('transform', 'translate(' + width / 2 + ',' + height / 2 + ')');

              function formatData(data){
                return _.reduce(data,function(memo, item, key){
                  memo.push({range: key, iterations: item});
                  return memo;
                },[]);
              }
              function change(newData){
                scope.svg.selectAll('g').remove()

                init(newData);
              }
              function init(data){
                initialized = true;
                g = scope.svg.selectAll('.arc')
                  .data(pie(formatData(data)))
                  .enter().append('g')
                  .attr('class', 'arc');

                g.append('path')
                  .attr('d', arc)
                  .style('fill', function(d, i) { return color(i); })
                  .each(function(d) { this.oldD = d; });

                g.append('text')
                  .attr('transform', function(d) {return 'translate(' + arc.centroid(d) + ')'; })
                  .attr('dy', '.35em')
                  .style('text-anchor', 'middle')
                  .style('fill','white')
                  .text(function(d) { return d.data.range; });

                g.attr('transform', 'translate('+ width / 2 +','+ width / 2 +')');

              }
            }
        };
      }
    };
  }]);
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').directive('playerStatTable', [
  '$routeParams', 'playerStats', 'filter', function($routeParams, playerStats, filter) {
    return {
      templateUrl: 'includes/partials/playerStatTable.html',
      restrict: 'E',
      scope: {
        playerName: '='
      },
      link: function(scope, element, attrs) {
        var api, init;
        api = null;
        playerStats.then(function(response) {
          api = response;
          return init();
        });
        scope.included = filter.included;
        scope.$watchCollection('included', function() {
          if (api != null) {
            api.setGames(filter.included);
          }
          scope.playerStats = api != null ? api.getAll()[scope.playerName].stats : void 0;
          return scope.teamAverage = api != null ? api.getAverages() : void 0;
        });
        return init = function() {
          api.setGames(scope.included);
          scope.playerStats = api.getAll()[scope.playerName].stats;
          scope.teamAverage = api.getAverages();
          return scope.statTypes = _.keys(scope.playerStats).sort();
        };
      }
    };
  }
]);
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').directive('rotating', function() {
  return {
    restrict: 'A',
    scope: {
      rotating: '='
    },
    compile: function() {
      return {
        pre: function(scope, element, attrs) {
          element.addClass('rotating');
          return scope.$watch('rotating', function(newVal, oldVal) {
            return element.css('-webkit-transform', 'rotate(' + newVal + 'deg)');
          });
        }
      };
    }
  };
});
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .directive('statFilter', function () {
    return {
      templateUrl: 'includes/partials/filter.html',
      restrict: 'EA',
      controller: 'FilterCtrl'
    };
  });
;'use strict';

angular.module('newBetaApp')
  .directive('statTables', function () {
    return {
      templateUrl: 'includes/partials/statTables.html',
      restrict: 'E',
      controller: 'StattablesCtrl'
    };
  });
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').directive('targetMap', [
  '$parse', function($parse) {
    return {
      templateUrl: 'includes/partials/targetMap.html',
      restrict: 'E',
      scope: {
        data: '='
      },
      link: function(scope, element, attrs) {
        var diameter, getText, height, render;
        scope.keyEvents = ['Drop', 'Catch', 'Throwaway', 'Goal'];
        scope.getColor = function(action) {
          var color;
          return color = (function() {
            switch (false) {
              case action !== 'Drop':
                return '#c5007c';
              case action !== 'Catch':
                return '#949A27';
              case action !== 'Throwaway':
                return '#ff9400';
              case action !== 'Goal':
                return '#298020';
              default:
                return '#c75aba';
            }
          })();
        };
        getText = function(data) {
          var at, dr, dv, plural, text;
          at = data.actionType;
          dv = data.value;
          dr = data.receiver;
          plural = dv > 1;
          return text = (function() {
            switch (false) {
              case at !== 'Throwaway':
                return dv + (plural ? ' throwaways' : ' throwaway');
              case at !== 'Catch':
                return dv + (plural ? ' passes to ' : ' pass to ') + dr;
              case at !== 'Goal':
                return dv + (plural ? ' Goals to ' : ' Goal to ') + dr;
              case at !== 'Drop':
                return dv + (plural ? ' dropped passes to ' : ' dropped pass to ') + dr;
              default:
                return at + ', ' + dr;
            }
          })();
        };
        height = parseInt($(element.parent()).css('width')) + 150;
        diameter = height - 150;
        $(element.parent()).css('height', height);
        scope.$watch('data', function() {
          return render();
        });
        window.onresize = function() {
          return render();
        };
        return render = function() {
          var bubble, color, format, node, svg, tooltip;
          if (scope.data) {
            d3.select('#target-map').select('svg').remove();
            format = d3.format(',d');
            color = d3.scale.category20c();
            tooltip = d3.select('#target-map').append('div').attr('class', 'target-mouseover-tooltip').text('a simple tooltip');
            bubble = d3.layout.pack().sort(null).size([diameter, height + 100]).padding(1.5);
            svg = d3.select('#target-map').append('svg').attr('width', diameter).attr('height', height + 100).attr('class', 'bubble');
            node = svg.selectAll('.node').data(bubble.nodes(scope.data).filter(function(d) {
              return !d.children;
            })).enter().append('g').attr('class', 'target-node').attr('transform', function(d) {
              return 'translate(' + d.x + ',' + d.y + ')';
            }).on('mouseover', function(d) {
              return tooltip.style('visibility', 'visible').text(getText(d));
            }).on('mousemove', function() {
              return tooltip.style('top', d3.event.y - 10 + 'px').style('left', d3.event.x + 10 + 'px');
            }).on('mouseout', function() {
              return tooltip.style('visibility', 'hidden');
            });
            node.append('circle').attr("r", function(d) {
              return d.r;
            }).style("fill", function(d) {
              return scope.getColor(d.actionType, true);
            });
            node.append('text').attr('dy', '.5em').style('text-anchor', 'middle').text(function(d) {
              return d.receiver.substring(0, d.r / 3);
            });
            return d3.select(self.frameElement).style('height', diameter + 'px');
          }
        };
      }
    };
  }
]);
;'use strict';

angular.module('newBetaApp')
  .directive('titleBar', ['$routeParams','teamName', function ($routeParams, teamName) {
    return {
      templateUrl: 'includes/partials/title-bar.html',
      restrict: 'EA',
      link: function postLink(scope) {
        if ( !_($routeParams).isEmpty() ){
          teamName.then(function(name){
            scope.teamName = name;
            window.document.title = name || 'iUltimate';
          });
        }
      }
    };
  }]);
;'use strict';

angular.module('newBetaApp')
  .filter('camelCase', function () {
    return function (name) {
      switch (name){
      case '':
        return '';
      default:
        var words = name.split(/(?=[A-Z])/g);
        words[0] = words[0][0].toUpperCase() + words[0].slice(1);
        return words.join(' ');
      }
    };
  });
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').filter('eventDescription', function() {
  return function(event) {
    switch (event.action) {
      case 'Catch':
        return event.passer + ' to ' + event.receiver;
      case 'Drop':
        return event.receiver + ' dropped from ' + event.passer;
      case 'Throwaway':
        if (event.type === 'Offense') {
          return event.passer + ' throwaway';
        } else {
          return 'Opponent throwaway';
        }
      case 'Stall':
        return event.passer + ' stalled';
      case 'MiscPenalty':
        return event.passer + ' penalized (caused turnover)';
      case 'D':
        return 'D by ' + event.defender;
      case 'Pull':
        return 'Pull by ' + event.defender;
      case 'PullOb':
        return 'Pull (Out of Bounds) by ' + event.defender;
      case 'Goal':
        if (event.type === 'Offense') {
          return 'Our Goal (' + event.passer + ' to ' + event.receiver + ')';
        } else {
          return 'Their Goal';
        }
      case 'Callahan':
        return 'Our Callahan (' + event.defender + ')';
      case 'EndOfFirstQuarter':
        return 'End of 1st Quarter';
      case 'EndOfThirdQuarter':
        return 'End of 3rd Quarter';
      case 'EndOfFourthQuarter':
        return 'End of 4th Quarter';
      case 'EndOfOvertime':
        return 'End of an Overtime';
      case 'Halftime':
        return 'Halftime';
      case 'GameOver':
        return 'Game Over';
      case 'Timeout':
        return 'Timeout';
      default:
        return event.action;
    }
  };
});
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').filter('eventImageUrl', function() {
  return function(event) {
    var url;
    url = 'images/cuties/';
    switch (event.action) {
      case 'Catch':
        url += 'big_smile.png';
        break;
      case 'Drop':
        url += 'eyes_droped.png';
        break;
      case 'Throwaway':
        url += event.type === 'Offense' ? 'shame.png' : 'exciting.png';
        break;
      case 'Stall':
        url += 'shame.png';
        break;
      case 'MiscPenalty':
        url += 'shame.png';
        break;
      case 'D':
        url += 'electric_shock.png';
        break;
      case 'Pull':
        url += 'nothing.png';
        break;
      case 'PullOb':
        url += 'what.png';
        break;
      case 'Goal':
        url += event.type === 'Offense' ? 'super_man.png' : 'cry.png';
        break;
      case 'Callahan':
        url += 'victory.png';
        break;
      case 'EndOfFirstQuarter':
        url += 'stopwatch1.png';
        break;
      case 'EndOfThirdQuarter':
        url += 'stopwatch1.png';
        break;
      case 'EndOfFourthQuarter':
        url += 'stopwatch1.png';
        break;
      case 'EndOfOvertime':
        url += 'stopwatch1.png';
        break;
      case 'Halftime':
        url += 'stopwatch1.png';
        break;
      case 'GameOver':
        url += 'finishflag.png';
        break;
      case 'Timeout':
        url += 'stopwatch1.png';
        break;
      default:
        url += 'money.png';
    }
    return url;
  };
});
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').filter('hundredths', function() {
  return function(input) {
    if (_(input).isNaN()) {
      return '?';
    } else if (_(input).isNumber()) {
      return input.toFixed(2).replace(/(\.00$)|(0*$)/, '');
    } else {
      return 'NA';
    }
  };
});
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').filter('upperCase', function() {
  return function(input) {
    if (_(input).isString()) {
      return input.slice(0, 1).toUpperCase() + input.slice(1);
    }
  };
});
;d3.sankey = function() {
  var sankey = {},
      nodeWidth = 24,
      nodePadding = 8,
      size = [1, 1],
      nodes = [],
      links = [];

  sankey.nodeWidth = function(_) {
    if (!arguments.length) return nodeWidth;
    nodeWidth = +_;
    return sankey;
  };

  sankey.nodePadding = function(_) {
    if (!arguments.length) return nodePadding;
    nodePadding = +_;
    return sankey;
  };

  sankey.nodes = function(_) {
    if (!arguments.length) return nodes;
    nodes = _;
    return sankey;
  };

  sankey.links = function(_) {
    if (!arguments.length) return links;
    links = _;
    return sankey;
  };

  sankey.size = function(_) {
    if (!arguments.length) return size;
    size = _;
    return sankey;
  };

  sankey.layout = function(iterations) {
    computeNodeLinks();
    computeNodeValues();
    computeNodeBreadths();
    computeNodeDepths(iterations);
    computeLinkDepths();
    return sankey;
  };

  sankey.relayout = function() {
    computeLinkDepths();
    return sankey;
  };

  sankey.link = function() {
    var curvature = .5;

    function link(d) {
      var x0 = d.source.x + d.source.dx,
          x1 = d.target.x,
          xi = d3.interpolateNumber(x0, x1),
          x2 = xi(curvature),
          x3 = xi(1 - curvature),
          y0 = d.source.y + d.sy + d.dy / 2,
          y1 = d.target.y + d.ty + d.dy / 2;
      return "M" + x0 + "," + y0
           + "C" + x2 + "," + y0
           + " " + x3 + "," + y1
           + " " + x1 + "," + y1;
    }

    link.curvature = function(_) {
      if (!arguments.length) return curvature;
      curvature = +_;
      return link;
    };

    return link;
  };

  // Populate the sourceLinks and targetLinks for each node.
  // Also, if the source and target are not objects, assume they are indices.
  function computeNodeLinks() {
    _(nodes).each(function(node) {
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    _(links).each(function(link) {
      var source = link.source,
          target = link.target;
      if (typeof source === "number") source = link.source = nodes[link.source];
      if (typeof target === "number") target = link.target = nodes[link.target];
      source.sourceLinks.push(link);
      target.targetLinks.push(link);
    });
  }

  // Compute the value (size) of each node by summing the associated links.
  function computeNodeValues() {
    _(nodes).each(function(node) {
      node.value = Math.max(
        d3.sum(node.sourceLinks, value),
        d3.sum(node.targetLinks, value)
      );
    });
  }

  // Iteratively assign the breadth (x-position) for each node.
  // Nodes are assigned the maximum breadth of incoming neighbors plus one;
  // nodes with no incoming links are assigned breadth zero, while
  // nodes with no outgoing links are assigned the maximum breadth.
  function computeNodeBreadths() {
    var remainingNodes = nodes,
        nextNodes,
        x = 0;

    while (remainingNodes.length) {
      nextNodes = [];
      _(remainingNodes).each(function(node) {
        node.x = x;
        node.dx = nodeWidth;
        _(node.sourceLinks).each(function(link) {
          nextNodes.push(link.target);
        });
      });
      remainingNodes = nextNodes;
      ++x;
    }

    //
    moveSinksRight(x);
    scaleNodeBreadths((size[0] - nodeWidth) / (x - 1));
  }

  function moveSourcesRight() {
    _(nodes).each(function(node) {
      if (!node.targetLinks.length) {
        node.x = d3.min(node.sourceLinks, function(d) { return d.target.x; }) - 1;
      }
    });
  }

  function moveSinksRight(x) {
    _(nodes).each(function(node) {
      if (!node.sourceLinks.length) {
        node.x = x - 1;
      }
    });
  }

  function scaleNodeBreadths(kx) {
    _(nodes).each(function(node) {
      node.x *= kx;
    });
  }

  function computeNodeDepths(iterations) {
    var nodesByBreadth = d3.nest()
        .key(function(d) { return d.x; })
        .sortKeys(d3.ascending)
        .entries(nodes)
        .map(function(d) { return d.values; });

    //
    initializeNodeDepth();
    resolveCollisions();
    for (var alpha = 1; iterations > 0; --iterations) {
      relaxRightToLeft(alpha *= .99);
      resolveCollisions();
      relaxLeftToRight(alpha);
      resolveCollisions();
    }

    function initializeNodeDepth() {
      var ky = d3.min(nodesByBreadth, function(nodes) {
        return (size[1] - (nodes.length - 1) * nodePadding) / d3.sum(nodes, value);
      });

      _(nodesByBreadth).each(function(nodes) {
        _(nodes).each(function(node, i) {
          node.y = i;
          node.dy = node.value * ky;
        });
      });

      _(links).each(function(link) {
        link.dy = link.value * ky;
      });
    }

    function relaxLeftToRight(alpha) {
      _(nodesByBreadth).each(function(nodes, breadth) {
        _(nodes).each(function(node) {
          if (node.targetLinks.length) {
            var y = d3.sum(node.targetLinks, weightedSource) / d3.sum(node.targetLinks, value);
            node.y += (y - center(node)) * alpha;
          }
        });
      });

      function weightedSource(link) {
        return center(link.source) * link.value;
      }
    }

    function relaxRightToLeft(alpha) {
      _(nodesByBreadth.slice().reverse()).each(function(nodes) {
        _(nodes).each(function(node) {
          if (node.sourceLinks.length) {
            var y = d3.sum(node.sourceLinks, weightedTarget) / d3.sum(node.sourceLinks, value);
            node.y += (y - center(node)) * alpha;
          }
        });
      });

      function weightedTarget(link) {
        return center(link.target) * link.value;
      }
    }

    function resolveCollisions() {
      _(nodesByBreadth).each(function(nodes) {
        var node,
            dy,
            y0 = 0,
            n = nodes.length,
            i;

        // Push any overlapping nodes down.
        nodes.sort(ascendingDepth);
        for (i = 0; i < n; ++i) {
          node = nodes[i];
          dy = y0 - node.y;
          if (dy > 0) node.y += dy;
          y0 = node.y + node.dy + nodePadding;
        }

        // If the bottommost node goes outside the bounds, push it back up.
        dy = y0 - nodePadding - size[1];
        if (dy > 0) {
          y0 = node.y -= dy;

          // Push any overlapping nodes back up.
          for (i = n - 2; i >= 0; --i) {
            node = nodes[i];
            dy = node.y + node.dy + nodePadding - y0;
            if (dy > 0) node.y -= dy;
            y0 = node.y;
          }
        }
      });
    }

    function ascendingDepth(a, b) {
      return a.y - b.y;
    }
  }

  function computeLinkDepths() {
    _(nodes).each(function(node) {
      node.sourceLinks.sort(ascendingTargetDepth);
      node.targetLinks.sort(ascendingSourceDepth);
    });
    _(nodes).each(function(node) {
      var sy = 0, ty = 0;
      _(node.sourceLinks).each(function(link) {
        link.sy = sy;
        sy += link.dy;
      });
      _(node.targetLinks).each(function(link) {
        link.ty = ty;
        ty += link.dy;
      });
    });

    function ascendingSourceDepth(a, b) {
      return a.source.y - b.source.y;
    }

    function ascendingTargetDepth(a, b) {
      return a.target.y - b.target.y;
    }
  }

  function center(node) {
    return node.y + node.dy / 2;
  }

  function value(link) {
    return link.value;
  }

  return sankey;
};;'use strict';

angular.module('newBetaApp')
  .service('Authorization', ['$q', '$location', 'api',function($q, $location, api) {
    return {
      ping: function(teamId){
        var deferred = $q.defer();
        api.retrieveTeam(teamId, false,
          function() {
            deferred.resolve();
          },
          function(error) {
            if (error.status === 401){
              $location.url(teamId + '/login');
            } else {
              $location.url('/404');
            }
            deferred.reject(error);
          }
        );
        return deferred.promise;
      }
    };
  }]);;/* global _ */

'use strict';

angular.module('newBetaApp')
  .factory('allGames', ['$q', '$routeParams', 'api', function($q, $routeParams, api) {
    var deferred = $q.defer();
    api.retrieveGamesData($routeParams.teamId,
      function success(response) {
        _.each(response, function(game) {
          game.date = new Date(game.msSinceEpoch);
          game.points = JSON.parse(game.pointsJson);
          delete game.pointsJson;
        });
        deferred.resolve(_.indexBy(response, 'gameId'));
      },
      function failure(e) {
        deferred.reject(e);
      }
    );
    return deferred.promise;
  }]);;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').factory('downloadUrl', [
  '$routeParams', 'api', function($routeParams, api) {
    return api.urlForStatsExportFileDownload($routeParams.teamId, null);
  }
]);
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .factory('filter', ['allGames',function (allGames) {
    var includedGames = [];
    function exclude(game){
      var index = _.indexOf(includedGames, game);
      index > -1 && includedGames.splice(index, 1);
    }
    function include(game){
      if (!_.contains(includedGames, game))
        includedGames.push(game);
    }
    function onlyInclude(games){
      includedGames.splice(0, includedGames.length);
      _.each(games, include);
    }
    allGames.then(function(response){
      allGames = response;
      onlyInclude(response);
    });
    return {
      includeAll: function(){onlyInclude(allGames)},
      included: includedGames,
      include: function(games){
        (_.isArray(games) || !games.gameId) ? _.each(games, include) : include(games);
      },
      onlyInclude: onlyInclude,
      exclude: function(games){
        if (_.isArray(games) || !games.gameId) {_.each(games, exclude);}
        else {exclude(games);}
      },
      contains: function(game){
        return _.chain(includedGames).pluck('gameId').contains(game.gameId).value();
      }
    };
  }]);
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').factory('gameStats', [
  '$q', 'allGames', 'playerStats', function($q, allGames, playerStats) {
    var api, deferred;
    deferred = $q.defer();
    $q.all([allGames, playerStats]).then(function(response) {
      allGames = response[0];
      playerStats = response[1];
      return deferred.resolve(api);
    });
    api = {};
    api.getFor = function(game) {
      var leaders, players, relevant, results;
      results = {};
      playerStats.setGames([game]);
      players = playerStats.getAll();
      relevant = _.where(allGames, {
        opponentName: game.opponentName
      });
      if (!_(relevant).isArray()) {
        relevant = [relevant];
      }
      results.record = _.countBy(relevant, function(game) {
        if (game.ours > game.theirs) {
          return 'wins';
        } else {
          return 'losses';
        }
      });
      _(results.record).defaults({
        wins: 0,
        losses: 0
      });
      leaders = {};
      _(['goals', 'assists', 'ds', 'throwaways', 'plusMinus']).each(function(type) {
        return leaders[type] = _.max(players, function(player) {
          return player.stats[type];
        });
      });
      results.leaders = leaders;
      return results;
    };
    return deferred.promise;
  }
]);
;// Generated by CoffeeScript 1.7.1
'use strict';
var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

angular.module('newBetaApp').factory('Line', [
  'lineStats', function(lineStats) {
    var Line, lineNum;
    lineStats.then(function(response) {
      return lineStats = response;
    });
    lineNum = 0;
    return Line = (function() {
      function Line() {
        this.addPlayer = __bind(this.addPlayer, this);
        this.stats = {};
        this.id = ++lineNum;
        this.players = [];
      }

      Line.prototype.addPlayer = function(player) {
        this.players = _.union(this.players, [player]);
        return this.updateStats();
      };

      Line.prototype.removePlayer = function(player) {
        this.players = _.without(this.players, player);
        return this.updateStats();
      };

      Line.prototype.updateStats = function() {
        return this.stats = lineStats.getStats(this.players);
      };

      return Line;

    })();
  }
]);
;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').factory('lineStats', [
  '$q', 'team', 'allGames', 'filter', function($q, team, allGames, filter) {
    var api, deferred, getStats, includedGames;
    deferred = $q.defer();
    includedGames = null;
    $q.all([team, allGames]).then(function(response) {
      includedGames = filter.included;
      team = response[0];
      return deferred.resolve(api);
    });
    getStats = function(players) {
      var consideredPoints, result;
      result = {};
      consideredPoints = [];
      _.each(includedGames, function(game) {
        return _.each(game.points, function(point) {
          if (_.intersection(point.line, players).length === players.length) {
            return consideredPoints.push(point);
          }
        });
      });
      result.consideredPoints = consideredPoints;
      return result;
    };
    api = {
      getPlayers: function() {
        return _.pluck(team.players, 'name');
      },
      getStats: getStats
    };
    return deferred.promise;
  }
]);
;'use strict';

angular.module('newBetaApp')
  .factory('next', function() {
    var next = '';
    return {
      get: function() {
        var temp = next;
        next = '';
        return temp;
      },
      set: function(val) {
        next = val;
      }
    };
  });;// Generated by CoffeeScript 1.7.1
'use strict';
angular.module('newBetaApp').factory('playerExtensionStats', [
  '$q', 'allGames', function($q, allGames) {
    var api, consideredGames, deferred, playerName;
    playerName = '';
    consideredGames = [];
    api = {
      setGames: function(games) {
        return consideredGames = games;
      },
      setPlayer: function(name) {
        return playerName = name;
      },
      getTargetMap: function() {
        var actions, children, playersThrows;
        children = [];
        playersThrows = [];
        _.each(consideredGames, function(game) {
          return _.each(game.points, function(point) {
            return _.each(point.events, function(event) {
              if (event.passer === playerName) {
                return playersThrows.push(event);
              }
            });
          });
        });
        actions = _.groupBy(playersThrows, 'action');
        _.each(actions, function(events, action) {
          var receivers;
          receivers = _.countBy(events, function(event) {
            return event.receiver || 'The Other Team';
          });
          return _.each(receivers, function(count, player) {
            return children.push({
              actionType: action,
              receiver: player,
              value: count
            });
          });
        });
        return {
          children: children
        };
      }
    };
    allGames.then(function(response) {
      allGames = response;
      return deferred.resolve(api);
    });
    deferred = $q.defer();
    return deferred.promise;
  }
]);
;/* global _ */

'use strict';

angular.module('newBetaApp')
  .factory('playerStats', ['$q', 'allGames', 'team',function($q, allGames, team) {

    var includedGames;
    var playerStats;
    var basicStatTypes = ['catches', 'drops', 'throwaways', 'stalls', 'penalized', 'ds', 'iBPulls', 'oBPulls', 'goals', 'callahans', 'thrownCallahans', 'assists', 'passesDropped', 'completions', 'timePlayed', 'pullHangtime', 'gamesPlayed', 'dPoints', 'oPoints', 'oPlusMinus', 'dPlusMinus','hungPulls'];


    function recordEvent(event, players) {
      var receiver = event.receiver;
      var passer = event.passer;
      var defender = event.defender;
      switch (event.action) {
      case 'Catch':
        players[receiver] && players[receiver].stats.catches++;
        players[passer] && players[passer].stats.completions++;
        break;
      case 'Drop':
        players[receiver] && players[receiver].stats.drops++;
        players[receiver] && players[receiver].stats.oPlusMinus--;
        players[passer] && players[passer].stats.passesDropped++;
        break;
      case 'Throwaway':
        players[passer] && players[passer].stats.throwaways++;
        players[passer] && players[passer].stats.oPlusMinus--;
        break;
      case 'Stall':
        players[passer] && players[passer].stats.stalls++;
        players[passer] && players[passer].stats.oPlusMinus--;
        break;
      case 'MiscPenalty':
        if (event.type === 'Offense'){
          players[passer] && players[passer].stats.penalized++;
        } else {
          players[defender] && players[defender].stats.penalized++;
        }
        break;
      case 'D':
        players[defender] && players[defender].stats.ds++;
        players[defender] && players[defender].stats.dPlusMinus++;
        break;
      case 'Pull':
        if (players[defender]){
          players[defender].stats.iBPulls++;
          if (event.details && event.details.hangtime) {
            players[defender].stats.hungPulls++;
            players[defender].stats.pullHangtime += (event.details.hangtime / 1000);
          }
        }
        break;
      case 'PullOb':
        if (players[defender]){
          players[defender].stats.oBPulls++;
        }
        break;
      case 'Goal':
        if (players[passer]){
          players[passer].stats.oPlusMinus++;
          players[passer].stats.completions++;
          players[passer].stats.assists++;
        }
        if (players[receiver]){
          players[receiver].stats.oPlusMinus++;
          players[receiver].stats.catches++;
          players[receiver].stats.goals++;
        }
        break;
      case 'Callahan':
        if (players[defender]){
          players[defender].stats.catches++;
          players[defender].stats.dPlusMinus++;
          players[defender].stats.oPlusMinus++;
          players[defender].stats.goals++;
          players[defender].stats.ds++;
          players[defender].stats.callahans++;
        }
        break;
      default:
        if (['EndOfFirstQuarter', 'Halftime', 'EndOfThirdQuarter', 'EndOfFourthQuarter', 'GameOver'].indexOf(event.action) < 0){
          throw new Error(event.action, ' is not a registered event.');
        }
      }
    }

    var derive = function() {
      var players = {};
      _(team.players).pluck('name').each(function(name){
        players[name] = {};
        players[name].stats = {};
        _.each(basicStatTypes, function(type){
          players[name].stats[type] = 0;
        });
      });

      _.each(includedGames, function(ref) {
        var playedInGame = {};
        _.each(allGames[ref.gameId].points, function(point) {
          _.each(point.line, function(name){
            if (players[name]) {
              if (!playedInGame[name]){
                players[name].stats.gamesPlayed++;
                playedInGame[name] = true;
              }
              point.summary.lineType === 'D' ? players[name].stats.dPoints++ : players[name].stats.oPoints++;
              players[name].stats.timePlayed += point.endSeconds - point.startSeconds;
            }
          });
          _.each(point.events, function(event){
            recordEvent(event, players);
          });
        });
      });
      _.each(players, function(player){
        extendPercentageStats(player.stats);
      });
      _.each(players, function(player, name){
        player.name = name;
      });
      _.each(players, function(player){
        extendAestheticStats(player.stats);
      });
      playerStats = players;
      return players;
    };
    function statSum(stats, types, negative){
      return _.reduce(types, function(memo,type){
        memo = negative ? memo - stats[type] : memo + stats[type];
        return memo;
      }, 0);
    }
    function extendAestheticStats(stats){
      stats.pointsPlayed = statSum(stats, ['oPoints', 'dPoints']);
      stats.pulls = statSum(stats, ['oBPulls', 'iBPulls']);
      stats.touches = statSum(stats, ['completions', 'throwaways', 'goals','passesDropped']);
      stats.plusMinus = statSum(stats, ['oPlusMinus', 'dPlusMinus']);
      stats.timePlayedMinutes = Math.round(stats.timePlayed / 60);
      stats.averagePullHangtime = stats.pullHangtime  / stats.hungPulls;
      _.each(['goals', 'assists', 'ds',  'throwaways',  'drops'], function(name){
        stats['pp' + name[0].toUpperCase() + name.slice(1)] = stats.pointsPlayed ? (stats[name] / stats.pointsPlayed) : 0;
      });
    }
    function extendPercentageStats(stats){
      _.each([
          ['catchingPercentage', 'catches', 'drops'],
          ['passingPercentage', 'completions', 'throwaways'],
          ['iBPullingPercentage', 'iBPulls', 'oBPulls']
        ], function(average){
          stats[average[0]] = Math.round(stats[average[1]] / (stats[average[1]] + stats[average[2]]) * 100);
        }
      );
    }
    function getLeaders(types){
      var leaders = {};
      _.each(types, function(type){
        leaders[type] = _.max(playerStats,function(player){
          return player.stats[type];
        });
      });
      return leaders;
    }
    function getTotals(){
      var totals = {};
      _.each(basicStatTypes, function(type){
        totals[type] = _.reduce(playerStats,getSumFunction(type));
      });
      extendPercentageStats(totals);
      extendAestheticStats(totals);
      return totals;
    }
    function getAverages(){
      var averages = {};
      var statTypes = _.keys(_.sample(playerStats).stats);
      _(statTypes).each(function(type){
        averages[type] = _.reduce(playerStats, getSumFunction(type)).valueOf() / _.keys(playerStats).length;
      });
      return averages;
    }
    function getSumFunction(type){
      return function(memo, player){
        if (_.isNumber(memo)) {
          return player.stats[type] ? memo + player.stats[type] : memo;
        } else {
          return player.stats[type];
        }
      };
    }

    //promise land
    $q.all([allGames, team]).then(function(responses){
      allGames = responses[0];
      team = responses[1];
      deferred.resolve({
        getLeaders: getLeaders,
        getTotals: getTotals,
        getAverages: getAverages,
        getAll: function(){return playerStats},
        getForPlayer: function(playerName){
          return playerStats[playerName];
        },
        setGames: function(games){
          includedGames = games;
          derive();
        }
      });
    });
    var deferred = $q.defer();
    return deferred.promise;
  }]);

// Assists Passes  Throwaways  Stalls  Percent Completed
// Goals Catches Touches Drops Percent Caught
// Games Played  PointsPlayed  Minutes Played  Offensive Points  Defensive Points
// D's Callahans Pulls Average Hang Time Out of Bounds Pulls
// Goals Assists Ds  Throwaways  Drops

;// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  angular.module('newBetaApp').factory('relocate', [
    '$location', '$routeParams', function($location, $routeParams) {
      var base;
      base = $routeParams.teamId + '/';
      return {
        goTo: function(route, query) {
          return $location.path(base + route + '/' + decodeURIComponent(query));
        }
      };
    }
  ]);

}).call(this);
;'use strict';

angular.module('newBetaApp')
  .factory('team', ['$q', '$routeParams', 'api',
    function($q, params, api) {
      var deferred = $q.defer();
      api.retrieveTeam(params.teamId, true,
        function success(result) {
          deferred.resolve(result);
        },
        function failure(e) {
          deferred.reject(e);
        }
      );
      return deferred.promise;
    }
  ]);;'use strict';

angular.module('newBetaApp')
  .factory('teamName', ['$q', 'team',function ($q, team) {
    var deferred = $q.defer();
    team.then(function(result){
      deferred.resolve(result.name);
    });
    return deferred.promise;
  }]);
;/* global _*/

'use strict';

angular.module('newBetaApp')
  .factory('teamStats', ['$q', '$routeParams', '$rootScope', 'filter', 'api', 'allGames',function($q, $routeParams, $rootScope, filter, api, allGames) {
    var deferred = $q.defer();
    var statsMap = {};
    var collection = 0;
    var goal;
    allGames.then(function(games) {
      goal = _.keys(games).length;
      _.each(games, function(game, id) {
        api.retrieveTeamStatsForGames($routeParams.teamId, [id],
          function success(result) {
            statsMap[id] = result;
            if (++collection === goal) {
              deferred.resolve(tsApi);
            }
          },
          function failure(e) {
            deferred.reject(e);
          }
        );
      });
    });
    var tsApi = {
      getFromIncluded: function() {
        var that = this;
        var result = {};
        var temp = $rootScope.$new();
        temp.included = filter.included;
        temp.$watchCollection('included', function() {
          _.extend(result,that.getFrom(filter.included));
        });
        return result;
      },
      getFrom: function(games) {
        var result = {};

        // Record
        var record = {
          wins: 0,
          losses: 0
        };
        _(games).each(function(game) {
          var gs = statsMap[game.gameId].goalSummary;
          gs.ourOlineGoals + gs.ourDlineGoals > gs.theirOlineGoals + gs.theirDlineGoals ? record.wins++ : record.losses++;
        });
        result.record = record;

        // Point Spread
        var ps = {
          ours: 0,
          theirs: 0
        };
        _(games).each(function(game) {
          var gs = statsMap[game.gameId].goalSummary;
          ps.ours += gs.ourDlineGoals + gs.ourOlineGoals;
          ps.theirs += gs.theirDlineGoals + gs.theirOlineGoals;
        });
        result.pointSpread = ps;

        // Offensive Conversion
        var offensiveOpps = 0;
        var offensiveConversions = 0;
        _(games).each(function(game) {
          _(game.points).each(function(point) {
            if (point.summary.lineType === 'O') {
              offensiveOpps++;
              if (point.events[point.events.length - 1].type === 'Offense') {
                offensiveConversions++;
              }
            }
          });
        });
        result.offensiveProductivity = offensiveOpps ? Math.round(offensiveConversions / offensiveOpps * 100) : 0;

        // Conversion Rate

        var scoringOpps = 0;
        _(games).each(function(game) {
          _(game.points).each(function(point) {
            if (point.summary.lineType === 'O') {
              scoringOpps++;
            }
            _(point.events).each(function(event) {
              if ((event.action === 'D' && event.type === 'Defense') || (event.action === 'Throwaway' && event.type === 'Defense')) {
                scoringOpps++;
              }
            });
          });
        });
        result.conversionRate = scoringOpps ? Math.round(result.pointSpread.ours / scoringOpps * 100) : 0;

        // Throws per possession
        var scored = [];
        var failed = [];
        var passes = 0;
        _(games).each(function(game) {
          _(game.points).each(function(point) {
            passes = 0;
            _(point.events).each(function(event) {
              if (event.type === 'Offense') {
                if (event.action === 'Catch') {
                  passes++;
                } else if (event.action === 'Goal') {
                  scored.push(++passes);
                  passes = 0;
                } else if (event.action === 'Throwaway' || event.action === 'Drop' || event.action === 'Turnover' || event.action === 'Stall') {
                  failed.push(++passes);
                  passes = 0;
                }
              } else {
                if (passes > 0) {
                  scored.push(passes);
                  passes = 0;
                }
              }
            });
          });
        });
        var tpp = {};
        var groupingFunc = function(num) {
          if (num === 1) {
            return '1';
          }
          if (num < 4) {
            return '4';
          }
          if (num < 8) {
            return '8';
          }
          if (num < 12) {
            return '12';
          }
          return '12+';
        };
        tpp.scored = _.countBy(scored, groupingFunc);
        tpp.failed = _.countBy(failed,groupingFunc);
        result.throwsPerPossession = tpp;

        // points scored by line
        var ps = {
          us: {
            offense: 0,
            defense: 0
          },
          them: {
            offense: 0,
            defense: 0
          }
        };

        _(games).each(function(game) {
          _(game.points).each(function(point) {
            if (point.events[point.events.length - 1].type === 'Offense') {
              point.summary.lineType === 'D' ? ps.us.defense++ : ps.us.offense++;
            } else {
              point.summary.lineType === 'D' ? ps.them.offense++ : ps.them.defense++;
            }
          });
        });

        result.pointSummary = ps;

        // goal flow

        var goalCount = result.pointSpread.ours;
        var assistMap = {nodes: {}, links: {}};
        _.each(games, function(game) {
          _.each(game.points, function(point) {
            var endEvent = point.events[point.events.length - 1];
            var penultimateEvent = point.events[point.events.length - 2];
            if (endEvent.type === 'Offense') { // if the goal was scored by the offense.
              var passer = endEvent.passer + 'P';
              var receiver = endEvent.receiver + 'R';
              if (penultimateEvent && penultimateEvent.type === 'Offense') {
                var penUPasser = penultimateEvent.passer + 'H';
                assistMap.nodes[penUPasser] = true;
                addLink(penUPasser, passer, assistMap);
              }
              assistMap.nodes[passer] = true;
              assistMap.nodes[receiver] = true;
              addLink(passer, receiver, assistMap);
            }
          });
        });
        var nodes = [];
        var i = 0;
        var map = {};
        _.each(assistMap.nodes, function(value, key) {
          map[key] = i;
          nodes[i] = {
            name: key
          };
          i++;
        });
        assistMap.nodes = nodes;
        var links = [];
        _.each(assistMap.links, function(receivers, thrower) {
          _.each(receivers, function(quantity, receiver) {
            links.push({
              source: map[thrower],
              target: map[receiver],
              value: quantity
            });
          });
        });
        assistMap.links = links;
        function addLink(passer, receiver, map) {
          if (map.links[passer]) {
            if (map.links[passer][receiver]) {
              map.links[passer][receiver] += 1;
            } else {
              map.links[passer][receiver] = 1;
            }
          } else {
            map.links[passer] = {};
            map.links[passer][receiver] = 1;
          }
        };

        result.assistMap = assistMap;
        return result;
      }
    };
    return deferred.promise;
  }]);;/* global $, angular, jQuery */
// written by Jim Geppert

'use strict';

angular.module('newBetaApp')
  .service('api', function Rest() {
    var exports = {};
    // init the global app object
    var Ultimate = {};

    Ultimate.busyDialogStack = 0;
    
    // make sure we use the host from where we were loaded to prevent CORS from being used unnecessarily
    // (unless the page is loaded locally in which case just use the default host)
    var restHost = window.location.host.indexOf("ultianlytics.com") === -1 ? "www.ultimate-numbers.com" : "www.ultianlytics.com";
    Ultimate.baseRestUrl = "http://" + restHost + '/rest/view';
    // make sure we use the host from where we were loaded to prevent CORS from being used unnecessarily
    Ultimate.sessionId = new Date().getTime() + '';

    exports.retrieveTeam = function(id, includePlayers, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveTeam');
      var url = Ultimate.baseRestUrl + '/team/' + id;
      url = includePlayers ? url + '?players=true' : url;
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    function retrieveTeamForAdmin(id, includePlayers, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveTeamForAdmin');
      var url = Ultimate.baseRestUrl + '/admin/team/' + id;
      url = includePlayers ? url + '?players=true' : url;
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    exports.retrieveGames = function(teamId, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveGames');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/games';
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    exports.retrieveGamesData = function(teamId, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveGames');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/gamesdata';
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    function retrieveGamesForAdmin(teamId, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveGamesForAdmin');
      var url = Ultimate.baseRestUrl + '/admin/team/' + teamId + '/games';
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    exports.retrieveGame = function(teamId, gameId, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveGame');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/game/' + gameId;
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    function deleteGame(teamId, gameId, successFunction, errorFunction) {
      sendAnalyticsEvent('deleteGame');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/game/' + gameId + '/delete';
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    function deleteTeam(teamId, successFunction, errorFunction) {
      sendAnalyticsEvent('deleteTeam');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/delete';
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    function deletePlayer(teamId, playerToDelete, replacementPlayer, successFunction, errorFunction) {
      sendAnalyticsEvent('deletePlayer');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/player/delete?player=' + playerToDelete + '&replacement=' + replacementPlayer;
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    function renamePlayer(teamId, playerToRename, replacementPlayer, successFunction, errorFunction) {
      sendAnalyticsEvent('renamePlayer');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/player/rename?player=' + playerToRename + '&replacement=' + replacementPlayer;
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    exports.retrievePlayerStatsForGames = function(teamId, gameIds, successFunction, errorFunction) {
      sendAnalyticsEvent('retrievePlayerStatsForGames');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/stats/player';
      if (gameIds !== null && gameIds.length > 0) {
        url = url + '?gameIds=' + gameIds.join('_');
      }
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    exports.retrieveTeamStatsForGames = function(teamId, gameIds, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveTeamStatsForGames');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/stats/team';
      if (gameIds !== null && gameIds.length > 0) {
        url = url + '?gameIds=' + gameIds.join('_');
      }
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    exports.retrievePlayerStatsForEachGame = function(teamId, gameIds, successFunction, errorFunction) {
      sendAnalyticsEvent('retrievePlayerStatsForGames');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/stats/player/games';
      if (gameIds !== null && gameIds.length > 0) {
        url = url + '?gameIds=' + gameIds.join('_');
      }
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    exports.retrieveAllStatsForGames = function(teamId, gameIds, successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveAllStatsForGames');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/stats/all';
      if (gameIds !== null && gameIds.length > 0) {
        url = url + '?gameIds=' + gameIds.join('_');
      }
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    function retrieveTeams(successFunction, errorFunction) {
      sendAnalyticsEvent('retrieveTeams');
      var url = Ultimate.baseRestUrl + '/teams';
      sendRequest({
        url: url,
        dataType: 'json',
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    function retrievePlayerStatsForGame(options, successFunction, errorFunction) {
      sendAnalyticsEvent('retrievePlayerStatsForGame');
      var teamId = options.teamId;
      retrievePlayerStatsForGames(teamId, [options.gameId], successFunction, errorFunction);
    }

    function savePassword(teamId, password, successFunction, errorFunction) {
      sendAnalyticsEvent('savePassword');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/password/' + (isNullOrEmpty(password) ? 'REMOVE-PASSWORD' : password);
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        success: successFunction,
        error: errorFunction || defaultError
      });
    }

    exports.signon = function(teamId, password, successFunction, errorFunction) {
            sendAnalyticsEvent('signon');
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/authenticate/' + password;
      sendRequest({
        url: url,
        dataType: 'json',
        isPost: true,
        success: successFunction,
        error: errorFunction || defaultError
      });
    };

    exports.urlForStatsExportFileDownload = function(teamId, games) {
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/stats/export';
      if (games) {
        var sortedGames = sortGames(games);
        var gameIds = collectGameIds(sortedGames);
        if (gameIds !== null && gameIds.length > 0) {
          url = url + '?gameIds=' + gameIds.join('_');
        }
      }
      return url;
    };

    function urlForGameExportFileDownload(teamId, gameId) {
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/export/game/' + gameId + '?players=true';
      return url;
    }

    function urlForGameExportFileUpload(teamId) {
      var returnUrl = encodeURIComponent('/team/admin#teamgamespage?team=' + teamId);
      var url = Ultimate.baseRestUrl + '/team/' + teamId + '/import/game?return=' + returnUrl;
      return url;
    }

    function sendRequest(request) {
      var options = {
        success: function(data, textStatus, jqXHR) {
          busyDialogEnd();
          var responseTypeReceived = jqXHR.getResponseHeader('Content-Type');
          if (isExpectedResponseType(request, jqXHR)) {
            request.success(data, textStatus, jqXHR);
          } else {
            logRequestFailure(jqXHR, 'unexpected response type = ' + responseTypeReceived);
          }
        },
        error: function(jqXHR, textStatus, errorThrown) {
          busyDialogEnd();
          var error = logRequestFailure(jqXHR, textStatus, errorThrown);
          if (request.error) {
            request.error(jqXHR, textStatus, errorThrown);
          } else {
            throw error;
          }
        }
      };
      if (request.dataType) {
        options.dataType = request.dataType;
      }
      if (request.isPost) {
        options.type = 'POST';
        options.contentType = 'application / json';
      }
      if (request.data) {
        options.data = request.data;
      }
      busyDialogStart();
      Ultimate.sessionId = 'foo ';
      var url = addQueryStringParameter(request.url, 'cachebuster ', Ultimate.sessionId);
      options.xhrFields = {
        withCredentials: true
      };
      $.ajax(url, options);
    }

    function isExpectedResponseType(request, responseTypeReceived) {
      if (request.expectedResponseType) {
        if (responseTypeReceived.indexOf(request.expectedResponseType) < 0) {
          return false;
        }
      }
      return true;
    }

    function addCommas(nStr) {
      nStr += '';
      var x = nStr.split('.');
      var x1 = x[0];
      var x2 = x.length > 1 ? '.' + x[1] : '';
      var rgx = /(\d+)(\d{3})/;
      while (rgx.test(x1)) {
        x1 = x1.replace(rgx, '$1' + ',' + '$2');
      }
      return x1 + x2;
    }

    function logRequestFailure(jqXHR, textStatus, errorThrow) {
      var error = errorDescription(jqXHR, textStatus, errorThrow);
      logError(error);
      return error;
    }

    function errorDescription(jqXHR, textStatus, errorThrow) {
      return 'ERROR: status ' + jqXHR.status + ' (' + textStatus + ') ' + errorThrow + (jqXHR.responseText ? ' \n' + jqXHR.responseText : '');
    }

    function getParameterByName(name) {
      var parts = window.location.href.split('?'); // jQM seems to pass odd urls sometimes (previous qs before current qs)
      var queryString = '?' + parts[parts.length - 1];
      var match = new RegExp('[?&]' + name + '=([^&]*)').exec(queryString);
      var value = match && decodeURIComponent(match[1].replace(/\+/g, ' '));
      return value;
    }

    function logError(error) {
      if (window.console) {
        console.log(error);
      }
    }

    // descending date-ordered list
    function sortGames(games) {
      var sortedGames = games.sort(function(a, b) {
        var first = a.msSinceEpoch ? a.msSinceEpoch : 0;
        var second = b.msSinceEpoch ? b.msSinceEpoch : 0;
        return second - first;
      });
      return sortedGames;
    }

    function collectGameIds(games) {
      var gameIds = [];
      $.each(games, function() {
        gameIds.push(this.gameId);
      });
      return gameIds;
    }


    // answer an array of object: {id: '
    //             TOURNAMENT - Centex - 2012 ', name: '
    //             Centex ', year: 2012, games:['
    //             game1234 ', '
    //             game345 ']} in reverse chrono order
    function getTournaments(games) {
      var tournamentsList = [];
      if (games && games.length > 0) {
        var sortedGames = sortGames(games);
        var tournamentGames = {};

        jQuery.each(sortedGames, function() {
          var name = this.tournamentName;
          if (name) {
            var year = this.msSinceEpoch ? new Date(this.msSinceEpoch).getFullYear() : '';
            var id = 'TOURNAMENT - ' + name + ' - ' + year;
            if (!tournamentGames[id]) {
              tournamentGames[id] = [];
              tournamentsList.push({
                id: id,
                name: name,
                year: year
              });
            }
            tournamentGames[id].push(this.gameId);
          }
        });

        jQuery.each(tournamentsList, function() {
          this.games = tournamentGames[this.id];
        });

        return tournamentsList;
      }
      return [];
    }

    function getInternetExplorerVersion(){
    // Returns the version of Internet Explorer or a -1 (indicating the use of another browser).
      var rv = -1; // Return value assumes failure.
      if (navigator.appName == 'Microsoft Internet Explorer ') {
        var ua = navigator.userAgent;
        var re = new RegExp('MSIE([0 - 9] {1, }[\.0 - 9] {0, }) ');
        if (re.exec(ua) !== null) rv = parseFloat(RegExp.$1);
      }
      return rv;
    }

    function log(message) {
      if (window.console) {
        console.log(message);
      }
    }

    function isNullOrEmpty(s) {
      return s == null || jQuery.trim(s) == '';
    }

    function busyDialogStart() {
      Ultimate.busyDialogStack++;
      if (Ultimate.busyDialogStack == 1) {
        $('.hideWhenBusy ').addClass('hidden ');
        $('.spinner ').removeClass('hidden ');
      }
    }

    function busyDialogEnd() {
      Ultimate.busyDialogStack--;
      if (Ultimate.busyDialogStack == 0) {
        resetBusyDialog();
      }
    }

    function resetBusyDialog() {
      $('.spinner ').addClass('hidden ');
      showHiddenWhenBusyElements();
      Ultimate.busyDialogStack == 0;
    }

    /*
    Creates a canonical string representation of the object which can be used for comparison or subsequent hash creation.  
    The object will be deeply recursed to find all objects. 
    Circular references are handled automatically (an object will not be re-visited once it has been handled).
    Thread-safe (designed to be a singleton)
    */
    Ultimate.Canonicalizer = function() {
      /*
        Return a canonical string of the object.
        Undefined properties are skipped.
        options: {  
        treatNullAsUndefined: boolean  By default NULL properties will be written.  To treat nulls like undefined specify treatNullAsUndefined
        treatEmptyStringsAsUndefined: boolean  By default empty string properties will be written.  To treat empty strings like undefined specify treatEmptyStringsAsUndefined
        <propertyName>: boolean   By default all other properties of an object are navigated.  To ignore a certain property add it to the options with value of true. 
        */
      this.toCanonicalString = function(object, options) {
        var allProps = [];
        var visitedObjects = [];
        pushObject(object, allProps, options, 0, visitedObjects);
        return allProps.join('');
      };

      function pushObject(obj, allProps, options, level, visitedObjects) {
        if (typeof obj == 'object' && obj !== null) {
          var visitedReference = getVisitedReference(obj, visitedObjects);
          if (visitedReference) {
            allProps[allProps.length] = visitedReference;
          } else {
            visitedObjects.push(obj);
            var props = [];
            for (var prop in obj) {
              props.push(prop);
            }
            props = props.sort();
            for (var i = 0; i < props.length; i++) {
              var childObj = obj[props[i]];
              if (shouldPush(childObj, options, props[i])) {
                allProps[allProps.length] = '\n';
                for (var j = 0; j < level; j++) {
                  allProps[allProps.length] = '.';
                }
                allProps[allProps.length] = props[i];
                allProps[allProps.length] = ':';
                pushObject(childObj, allProps, options, level + 1, visitedObjects);
              }
            }
          }
        } else {
          allProps[allProps.length] = obj == null ? 'null' : obj;
        }
      }

      function shouldPush(value, options, propName) {
        if (propName && options[propName]) {
          return false;
        } else if (typeof value == 'function' || value === undefined) {
          return false;
        } else if (options.treatNullAsUndefined && value === null) {
          return false;
        } else if (options.treatEmptyStringsAsUndefined && value == '') {
          return false;
        }
        return true;
      }

      function getVisitedReference(object, visitedObjects) {
        for (var i = 0; i < visitedObjects.length; i++) {
          if (visitedObjects[i] === object) {
            return '@REF' + i;
          }
        }
        return null;
      }

    };

    function showHiddenWhenBusyElements() {
      $('.hideWhenBusy').removeClass('hidden');
    }

    function hideHiddenWhenBusyElements() {
      $('.hideWhenBusy').addClass('hidden');
    }

    function addQueryStringParameter(url, key, value) {
      return url + (url.indexOf('?') > 0 ? '&' : '?') + key + '=' + value;
    }

    function resetCacheBuster() {
      Ultimate.sessionId = new Date().getTime() + '';
    }

    function sendAnalyticsEvent(restEndpointName) {
      // NOTE: You can add another property for more detail
      // commented out for testing
      //_gaq.push(['_trackEvent', Ultimate.isAdminSite ? 'WebRestRequest-Admin' : 'WebRestRequest', restEndpointName]);
    }

    function defaultError(e){
      throw e;
    }
    // AngularJS will instantiate a singleton by calling 'new' on this function
    return exports;
  });;'use strict';

angular.module('newBetaApp')
  .factory('viewer', function () {
    return {
      isMobile: function () {
        return /Android|webOS|iPhone|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      }
    };
  });
;/****************  PLAYER STATS ACCUMULATOR ********************/

/*
	Summarizes raw game data for a team, producing the same player stats object that is
	returned by retrievePlayerStatsForGames(), AKA endpoint /team/{teamId}/stats/player.
	The game data should be in the same format as that returned by retrieveGamesData(),
	AKA /team/{teamId}/gamesdata.  That is, game objects with point data that is embedded JSON.

	Equivalent functionality to java class PlayerStatisticsCalculator

*/
var PlayerStatsAccumulator = function() {
	var UNREASONABLY_LONG_ELAPSED_TIME_MINUTES = 60;
	var DEFAULT_POINT_ELAPSED_MINUTES = 5;

	this.summarizeGameData = function(arrayOfGameData) {
		var allPlayerStats = {};
		for (var i = 0; i < arrayOfGameData.length; i++) {
			updateStatsForGame(allPlayerStats, arrayOfGameData[i]);
		}
		return allPlayerStats;
	}

	function updateStatsForGame(allPlayerStats, game) {
		var playedInGame = [];
		var points = JSON.parse(game.pointsJson);
		for (var i = 0; i < points.length; i++) {
			var point = points[i];
			updateTimePlayedStats(allPlayerStats, point);

			var events = point.events;
			var lastEvent = null;
			for (var j = 0; j < events.length; j++) {
				var event = events[j];
				var passer = isOffense(event) && event.passer != null ? getStatsForPlayer(allPlayerStats,event.passer) : null;
				var receiver = isOffense(event) && event.receiver != null ? getStatsForPlayer(allPlayerStats,event.receiver) : null;
				var defender = isDefense(event) && event.defender != null ? getStatsForPlayer(allPlayerStats,event.defender) : null;

				if (event.action == 'Catch') {
					passer.passes++;
					receiver.catches++;
					receiver.touches++;
					if (isFirstOffenseEvent(event, lastEvent)) {
						passer.touches++;
					}
				} else if (event.action == 'Drop') {
					passer.passes++;
					receiver.drops++;
					receiver.plusMinusCount--;
					if (isFirstOffenseEvent(event, lastEvent)) {
						passer.touches++;
					}
				} else if (isOffense(event) && (event.action == 'Throwaway' || event.action == 'Stall' || event.action == 'MiscPenalty')) {
					passer.passes++;
					if (event.action == 'Throwaway') {
						passer.throwaways++;
					} else if (event.action == 'Stall') {
						passer.stalls++;
					} else if (event.action == 'MiscPenalty') {
						passer.miscPenalties++;
					}
					passer.plusMinusCount--;
					if (isFirstOffenseEvent(event, lastEvent)) {
						passer.touches++;
					}
				} else if (event.action == 'Pull') {
					defender.pulls++;
					updateHangtimeForPull(event, defender);
				} else if (event.action == 'PullOb') {
					defender.pullsOB++;
				} else if (event.action == 'D') {
					defender.ds++;
					defender.plusMinusCount++;
				} else if (event.action == 'Callahan') {
					if (isDefense(event)) {
						defender.callahans++;
						defender.goals++;
						defender.ds++;
						defender.touches++;
						defender.plusMinusCount++;
						defender.plusMinusCount++; // double for a callahan
						updatePlusMinusLine(allPlayerStats, point, true, isOline(point));
					} else {
						passer.passes++;
						passer.throwaways++;
						passer.callahaneds++;
						passer.plusMinusCount--;
						updatePlusMinusLine(allPlayerStats, point, false, isOline(point));
					}
				} else if (event.action == 'Goal') {
					if (isOffense(event)) {
						passer.assists++;
						passer.passes++;
						receiver.touches++;
						receiver.goals++;
						receiver.catches++;
						passer.plusMinusCount++;
						receiver.plusMinusCount++;
						if (isFirstOffenseEvent(event, lastEvent)) {
							passer.touches++;
						}
					}
					updatePlusMinusLine(allPlayerStats, point, isOffense(event), isOline(point));
				}
				if (isOffense(event) && passer != null && passer.passes > 0) {
					var passPercent = (passer.passes - passerTurnovers(passer)) / passer.passes * 100;
					passer.passSuccess = Math.round(passPercent);
				}
				if (isOffense(event) && receiver != null && receiver.catches > 0) {
					var catchPercent = receiver.catches / (receiver.catches + receiver.drops) * 100;
					receiver.catchSuccess = Math.round(catchPercent);
				}
				lastEvent = event;
			}
            updatePointsPlayedStats(allPlayerStats, point, playedInGame);
		}
		for (var k = 0; k < playedInGame.length; k++) {
			getStatsForPlayer(allPlayerStats,playedInGame[k]).gamesPlayed++;
		}
	}

	function updateTimePlayedStats(allPlayerStats, point) {
		if (point.line) {
			var playersInEntirePoint = getPlayersInEntirePoint(point);
			var playersInPartOfPoint = getPlayersInPartOfPoint(point);
			// players who played all of point
			for (var i = 0; i < playersInEntirePoint.length; i++) {
				var playerStats = getStatsForPlayer(allPlayerStats, playersInEntirePoint[i]);
				playerStats.secondsPlayed += elapsedTimeForPoint(point);
			}
			// players that were subbed in/out (ascribe half of the point time)
			for (var i = 0; i < playersInPartOfPoint.length; i++) {
				var playerStats = getStatsForPlayer(allPlayerStats, playersInPartOfPoint[i]);
				var elapsedTime = elapsedTimeForPoint(point);
				if (elapsedTime) {
					elapsedTime = elapsedTime / 2;
				}
				playerStats.secondsPlayed += elapsedTime;
			}
		}
	}

	function updatePointsPlayedStats(allPlayerStats, point, playedInGame) {
		if (point.line) {
			var playersInEntirePoint = getPlayersInEntirePoint(point);
			var playersInPartOfPoint = getPlayersInPartOfPoint(point);
			// players who played all of point
			for (var i = 0; i < playersInEntirePoint.length; i++) {
				var name = playersInEntirePoint[i];
				addPlayerName(playedInGame, name);
				var playerStats = getStatsForPlayer(allPlayerStats, name);
				playerStats.pointsPlayed++;
				if (isOline(point)) {
					playerStats.oPointsPlayed++;
				} else {
					playerStats.dPointsPlayed++;
				}
			}
			// players who played in part of point
			for (var i = 0; i < playersInPartOfPoint.length; i++) {
				var name = playersInPartOfPoint[i];
				addPlayerName(playedInGame, name);
				var playerStats = getStatsForPlayer(allPlayerStats, name);
				playerStats.pointsPlayed += .5;
				if (isOline(point)) {
					playerStats.oPointsPlayed += .5;
				} else {
					playerStats.dPointsPlayed += .5;
				}
			}
		}
	}

	function updatePlusMinusLine(allPlayerStats, point, isOurGoal, isOline) {
		if (point.line) {
			for (var i = 0; i < point.line.length; i++) {
				var playerName = point.line[i];
				var playerStats = getStatsForPlayer(allPlayerStats,playerName);
				if (isOurGoal) {
					if (isOline) {
						playerStats.plusMinusOLine++;
					} else {
						playerStats.plusMinusDLine++
					}
				} else {
					if (isOline) {
						playerStats.plusMinusOLine--;
					} else {
						playerStats.plusMinusDLine--;
					}
				}
			}
		}
	}

	// answer the players that played during the entire point (were not
	// substituted in or out)
	function getPlayersInEntirePoint(point) {
		if (point.line) {
			if (point.substitutions) {
				var players = point.line.slice();
				for (var i = 0; i < point.substitutions.length; i++) {
					var fromPlayer = point.substitutions[i].fromPlayer;
					var toPlayer = point.substitutions[i].toPlayer;
					// drop both players that are part of a substitution
					removePlayerName(players, fromPlayer);
					removePlayerName(players, toPlayer);
				}
				return players;
			} else {
				return point.line
			}
		} else {
			return [];
		}
	}

	// answer the players that were substituted in or out during the point
	function getPlayersInPartOfPoint(point) {
		if (point.substitutions) {
			var players = [];
			for (var i = 0; i < point.substitutions.length; i++) {
				var fromPlayer = point.substitutions[i].fromPlayer;
				var toPlayer = point.substitutions[i].toPlayer;
				// add both players that are part of a substitution
				addPlayerName(players, fromPlayer);
				addPlayerName(players, toPlayer);
			}
			return players;
		} else {
			return [];
		}
	}

	function getStatsForPlayer(allPlayerStats, name) {
		var playerStats = allPlayerStats[name];
		if (!playerStats) {
			playerStats = {};
			allPlayerStats[name] = playerStats;

			playerStats.playerName = name;
			playerStats.plusMinusCount = 0;
			playerStats.plusMinusOLine = 0;
			playerStats.plusMinusDLine = 0;
			playerStats.gamesPlayed = 0;
			playerStats.pointsPlayed = 0;
			playerStats.oPointsPlayed = 0;
			playerStats.dPointsPlayed = 0;
			playerStats.goals = 0;
			playerStats.callahans = 0;
			playerStats.callahaneds = 0;
			playerStats.assists = 0;
			playerStats.passes = 0;
			playerStats.passSuccess = 0;
			playerStats.catches = 0;
			playerStats.catchSuccess = 0;
			playerStats.drops = 0;
			playerStats.throwaways = 0;
			playerStats.stalls = 0;
			playerStats.miscPenalties = 0;
			playerStats.ds = 0;
			playerStats.pulls = 0;
			playerStats.pullsWithHangtime = 0;
			playerStats.pullsOB = 0;
			playerStats.pullsTotalHangtime = 0;
			playerStats.pullsAvgHangtimeMillis = 0;
			playerStats.touches = 0;
			playerStats.secondsPlayed = 0;

		}
		return playerStats;
	}

	function removePlayerName(names, playerName) {
		var i = names.indexOf(playerName);
		if (i != -1) {
			names.splice(i, 1);
		}
	}

	function addPlayerName(names, playerName) {
		// don't add it if already there
		for (var i = 0; i < names.length; i++) {
			if (names[i] == playerName) {
				return;
			}
		}
		names.push(playerName);
	}

	function isOline(point) {
		return point.summary.lineType == 'O';
	}

	function isDline(point) {
		return point.summary.lineType == 'D';
	}

	function elapsedTimeForPoint(point) {
		var elapsedTime = point.summary.elapsedTime;
		if (!elapsedTime) {
			elapsedTime = 0;
		}
		return elapsedTime > UNREASONABLY_LONG_ELAPSED_TIME_MINUTES * 60 ? DEFAULT_POINT_ELAPSED_MINUTES * 60 : elapsedTime;
	}

	function isOffense(event) {
		return event.type == 'Offense';
	}

	function isDefense(event) {
		return event.type == 'Defense';
	}

	function isFirstOffenseEvent(event, previousEvent) {
		return isOffense(event) && (previousEvent == null || !(isOffense(previousEvent)));
	}

	function updateHangtimeForPull(pullEvent, playerStat) {
		if (pullEvent.details && pullEvent.details.hangtime) {
			playerStat.pullsWithHangtime++;
			playerStat.pullsTotalHangtime += pullEvent.details.hangtime;
			playerStat.pullsAvgHangtimeMillis = playerStat.pullsTotalHangtime / playerStat.pullsWithHangtime;
		}
	}

	function passerTurnovers(playerStat) {
		return playerStat.throwaways + playerStat.stalls + playerStat.miscPenalties;
	}

}
